rule grammar
  ws? rules:parsing_rule*
end

rule parsing_rule
  'rule' ws :rule_name parameters:( '[' local_value{ ',' ws }* ']' )? ws child:rule_expression 'end' ws
end

rule rule_expression
  ws? choice
end

rule choice
  first_child:creator '/' ws second_child:choice <Choice> /
  creator
end

rule creator
  child:sequence '<' class_name:alphanumeric_char+ ( ws :data )? '>' ws <ObjectCreator> /
  child:sequence '{' :code '}' ws <ValueCreator> /
  sequence
end

rule data
  quoted_string <StringData> /
  ( 'true' value:$true / 'false' value:$false ) <BooleanData> /
  '{' entries:( ws label:alphanumeric_char+ ':' ws :data ){ ',' }* ws '}' <HashData> /
  '[' entries:( ws data ){ ',' }* ws ']' <ArrayData> /
  '<' class_name:alphanumeric_char+ ws :data '>' <ObjectData> /
  '@' @:alphanumeric_char+ <LabelData>
end

rule code
  @:( ![{}] . / '{' code '}' )*
end

rule sequence
  children:labeled+ <Sequence>
end

rule labeled
  ( '%' is_local:$true )? name:( '@' / alpha_char alphanumeric_char* ) ':' child:lookahead <Label> /
  lookahead
end

rule lookahead
  '&' child:repetition <PositiveLookahead> /
  '!' child:repetition <NegativeLookahead> /
  repetition
end

rule repetition
  child:primary '?' ws <Choice { first_child: @child, second_child: <EmptyParsingExpression { }> }> /
  child:primary '*->' until_expression:primary <Until> /
  child:primary ( '{' ws glue_expression:choice '}' )? ( '*' at_least_once:$false / '+' at_least_once:$true ) ws <Repetition> /
  primary ws
end

rule primary
  (
    terminal /
    rule_call_label /
    parenthesized_expression /
    local_value /
    function
  )
end

rule parenthesized_expression
  '(' ws ')' <EmptyParsingExpression> /
  '(' ws child:choice ')' <ParenthesizedExpression>
end

rule local_value
  '%' name:( alpha_char alphanumeric_char* ) <LocalValue>
end

rule rule_call_label
  ":" child:rule_call <RuleCallLabel> /
  rule_call
end

rule rule_call
  name:rule_name arguments:( '[' local_value{ ',' ws }* ']' )? <RuleCall>
end

rule rule_name
  !keyword @:( alpha_char alphanumeric_char* )
end

rule terminal
  content:quoted_string <StringTerminal> /
  '[' ( '^' inverted:$true )? selections:( character_class_range / character_class_single_character )+ ']' <CharacterClassTerminal> /
  '.' <CharacterClassTerminal { selections: [ <CharacterClassEscapedCharacter { character: "0" }> ], inverted: true }>
end

rule function
  '$true' <TrueFunction> /
  '$false' <FalseFunction> /
  '$match' '[' child:local_value ']' <MatchFunction> /
  '$error' '[' message:quoted_string ']' <ErrorFunction> /
  '$enter_mode' '[' name:quoted_string ',' ws child:choice ']' <EnterModeFunction> /
  '$leave_mode' '[' name:quoted_string ',' ws child:choice ']' <LeaveModeFunction> /
  '$in_mode' '[' name:quoted_string ']' <InModeFunction>
end

rule quoted_string
  '"' @:( !'"' ( "\\\\" / '\"' / . ) )* '"' /
  "'" @:( !"'" ( "\\\\" / "\\'" / . ) )* "'"
end

rule character_class_single_character
  '\\' character:. <CharacterClassEscapedCharacter> /
  ( !']' ) character:. <CharacterClassSingleCharacter>
end

rule character_class_range
  begin_char:character_class_single_character '-' end_char:character_class_single_character <CharacterClassRange>
end

rule keyword
  ( 'rule' / 'end' ) &single_ws
end

rule alpha_char
  [A-Za-z_]
end

rule alphanumeric_char
  alpha_char / [0-9]
end

rule ws
  single_ws+ / &']' / &'\0'
end

rule single_ws
  [ \t\n\r] / line_comment
end

rule line_comment
  '#' [^\n]*
end
