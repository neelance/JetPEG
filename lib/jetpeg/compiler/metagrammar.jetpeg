rule grammar
  ws? rules:parsing_rule*
end

rule parsing_rule
  "rule" ws :rule_name parameters:( "[" local_value{ "," ws }* "]" )? ws child:rule_expression "end" ws
end

rule rule_expression
  ws? choice[$false]
end

rule choice[%nested_choice]
  first_child:creator "/" ws second_child:choice[$true] nested_choice:%nested_choice <Choice> /
  creator
end

rule creator
  child:sequence "<" class_name:alphanumeric_char+ ( ws :data )? ">" ws <ObjectCreator> /
  child:sequence "{" :code "}" ws <ValueCreator> /
  sequence
end

rule data
  string:( "\"" @:( !"\"" ( "\\" . / . ) )* "\"" ) <StringData> /
  ( "true" value:$true / "false" value:$false ) <BooleanData> /
  "{" entries:( ws label:alphanumeric_char+ ":" ws :data ){ "," }* ws "}" <HashData> /
  "[" entries:( ws data ){ "," }* ws "]" <ArrayData> /
  "<" class_name:alphanumeric_char+ ws :data ">" <ObjectData> /
  "@" name:alphanumeric_char+ <LabelData>
end

rule code
  @:( ![{}] . / "{" code "}" )*
end

rule sequence
  first_child:labeled second_child:sequence <Sequence> /
  labeled
end

rule labeled
  ( "%" is_local:$true )? name:( "@" / alpha_char alphanumeric_char* ) ":" child:lookahead <Label> /
  lookahead
end

rule lookahead
  "&" child:repetition <PositiveLookahead> /
  "!" child:repetition <NegativeLookahead> /
  repetition
end

rule repetition
  child:primary "?" ws <Choice { first_child: @child, second_child: <EmptyParsingExpression { }> }> /
  child:primary "*->" until_expression:primary <Until> /
  child:primary ( "{" ws glue_expression:choice[$false] "}" )? ( "*" at_least_once:$false / "+" at_least_once:$true ) ws <Repetition> /
  primary ws
end

rule primary
  terminal /
  rule_call_label /
  parenthesized_expression /
  function /
  local_value
end

rule parenthesized_expression
  "(" ws ")" <EmptyParsingExpression { }> /
  "(" ws child:choice[$false] ")" <ParenthesizedExpression>
end

rule argument
  "\"" string:( !"\"" ( "\\" . / . ) )* "\"" <StringValue> /
  function /
  local_value /
  choice[$false]
end

rule function
  "$" name:alphanumeric_char+ ( "[" arguments:argument{ "," ws }+ "]" )? <Function>
end

rule local_value
  "%" name:( alpha_char alphanumeric_char* ) <LocalValue>
end

rule rule_call_label
  ":" child:rule_call <RuleCallLabel> /
  rule_call
end

rule rule_call
  name:rule_name arguments:( "[" argument{ "," ws }* "]" )? <RuleCall>
end

rule rule_name
  !keyword @:( alpha_char alphanumeric_char* )
end

rule terminal
  "\"" chars:char_sequence "\"" <StringTerminal> /
  "[" ( "^" inverted:$true )? selections:( character_class_range / character_class_single_character )+ "]" <CharacterClassTerminal> /
  "." <CharacterClassTerminal { selections: [ <CharacterClassSingleCharacter { character: "\0" }> ], inverted: true }>
end

rule char_sequence
  char:character rest:char_sequence <CharacterSequence> /
  character
end

rule character
  !"\"" char:( "\\" . / . ) <Character>
end

rule character_class_single_character
  ( !"]" ) character:( "\\" . / . ) <CharacterClassSingleCharacter>
end

rule character_class_range
  begin_char:character_class_single_character "-" end_char:character_class_single_character <CharacterClassRange>
end

rule keyword
  ( "rule" / "end" ) &single_ws
end

rule alpha_char
  [A-Za-z_]
end

rule alphanumeric_char
  alpha_char / [0-9]
end

rule ws
  single_ws+ / &"]" / &"\0"
end

rule single_ws
  [ \t\n\r] / line_comment
end

rule line_comment
  "#" [^\n]*
end
